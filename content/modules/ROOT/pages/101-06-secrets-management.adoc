= Lab: Don’t Hardcode – Managing Secrets the Right Way
:labid: LAB-101-06
:cis-summary: "Store credentials as Secrets (files or env) instead of hardcoding; support rotation."
:mitre-summary: "Prevents credential exposure by replacing hardcoded values with scoped Secrets and enabling rotation paths."
:audit-evidence: "Hardcoded env var visible in manifest; refactored to Secret env/file; file mount updates after rotation while env requires restart."
:cis-mitre-codes: '{"cisMapping":{"primary":["5.4.1"],"related":[]},"mitre":{"techniques":["T1552"],"tactics":["TA0006"],"mitigations":["M1026"]}}'
:toc:
:sectnums:
:icons: font

== Skill
Remove passwords from manifests, store them as Secrets, inject safely, rotate cleanly.

== Objective

* Insecure hardcoded credential
* Refactor to Secret env var
* Refactor to Secret file mount
* Rotate and compare behaviors

== Why it Matters
Hardcoding credentials is like writing your ATM PIN on the card, anyone who sees it can use it. Storing passwords in Git, manifests, or images spreads them too widely and makes rotation painful. Kubernetes Secrets separate credentials from code, restrict access via RBAC, and support safe rotation (files update in place; env vars on restart), improving security and compliance.

== What it Solves

* Git history leakage
* Rotation friction
* Broad manifest visibility
* Credential reuse temptation

== Understanding the Attack Surface
[cols="1,2,2",options="header"]
|===
|Weak Practice | Risk | Exploitable Outcome
|Plaintext in Git | Persistent disclosure | Former employees retain copies
|Shared Across Apps | Lateral compromise | One breach unlocks many
|No Rotation | Long lifetime | Credential stuffing success
|Env Only Rotation | Missed restart | Stale secret in use
|===

== How to Secure (Lifecycle View)
* Build: Never bake secrets in images.
* Registry: Keep only non-sensitive config baked.
* Deploy: Use Secrets + least privilege RBAC.
* Runtime: Rotate high-value secrets; monitor access.

== Concepts: Secrets vs Hardcoding, Env vs File

*Hardcoding* credentials in deployment manifests or environment variables means the plaintext appears in YAML, Git history, and anyone with access to the deployment spec. Kubernetes *Secrets* store sensitive data separately and can be referenced by name; the manifest then contains only a reference, not the value. Access is controlled by RBAC (who can get/list the Secret), and you can inject secrets into pods in two ways: as *environment variables* (from the Secret) or as *files* mounted from the Secret. Each key in the Secret becomes an env var or a file. Secrets are base64-encoded in etcd unless you enable encryption-at-rest; treat them as "better than plaintext in manifests," not as vault-level encryption by default.

*Rotation* behavior differs: when you update a Secret, pods that *mount* the Secret as a volume see the new values automatically (Kubernetes updates the mounted files). Pods that use the Secret only as *env vars* keep the old value until the pod is restarted. So for credentials you rotate often, prefer file mounts; for simple one-off config, env is fine but remember to restart after rotation.

== How to Try It

You will create a project, deploy an app with a hardcoded password and show it in the manifest, remove it, then create a Secret and use it two ways: as an env var and as a mounted file. Finally you will rotate the Secret and observe that the file-mounted app sees the new value immediately while the env-based app needs a restart. All commands use the namespace `101-06-s-secrets`.

=== Use case 1: Create project and insecure deployment
Create the project and deploy an app with a hardcoded password in an environment variable. Then show that the plaintext appears in the deployment spec—the problem you are fixing.

*Procedure*

. Create the project:

[source,sh]
----
oc new-project 101-06-s-secrets
----

. Create a deployment and set a plaintext password via env:

[source,sh]
----
oc create deployment insecure-app -n 101-06-s-secrets --image=registry.access.redhat.com/ubi9/ubi -- sleep infinity
oc set env deployment/insecure-app -n 101-06-s-secrets DB_PASSWORD=SuperSecret123
----

. Inspect the deployment spec; the password is visible in plaintext:

[source,sh]
----
oc get deploy insecure-app -n 101-06-s-secrets -o yaml | grep -n 'SuperSecret'
----

*Expected:* A line showing `SuperSecret123` in the env section. Anyone with read access to the deployment (or Git, if this were committed) sees the credential.

IMPORTANT: Never commit real credentials to Git. Use placeholders in examples and store real values in Secrets or an external secret store. Repo scanners (e.g., gitleaks) can detect accidental commits.

=== Use case 2: Remove insecure workload and create a Secret
Delete the insecure deployment and create a Kubernetes Secret holding the same key. The Secret is a separate object; the deployment will reference it by name instead of embedding the value.

*Procedure*

. Delete the insecure deployment:

[source,sh]
----
oc delete deployment insecure-app -n 101-06-s-secrets
----

. Create a generic Secret with a literal key-value pair:

[source,sh]
----
oc create secret generic db-credentials -n 101-06-s-secrets --from-literal=DB_PASSWORD=SuperSecret123
----

. Verify the Secret exists (values are base64-encoded in the cluster, not shown here in plaintext by default):

[source,sh]
----
oc get secret db-credentials -n 101-06-s-secrets
----

TIP: Use `oc create secret generic` with `--from-literal` or `--from-file` for individual keys. Restrict who can get/list this Secret via RBAC so only the workloads that need it can reference it.

=== Use case 3: Deployment using Secret as env var
Create a deployment that pulls the Secret into its environment variables. The manifest will reference the Secret by name; the plaintext will not appear in the deployment YAML.

*Procedure*

. Create the deployment and inject env vars from the Secret:

[source,sh]
----
oc create deployment secure-app-env -n 101-06-s-secrets --image=registry.access.redhat.com/ubi9/ubi -- sleep infinity
oc set env deployment/secure-app-env -n 101-06-s-secrets --from=secret/db-credentials
----

. Wait for the pod and confirm the app sees the variable (value is present at runtime):

[source,sh]
----
oc wait --for=condition=Available deployment/secure-app-env -n 101-06-s-secrets --timeout=90s
oc exec deploy/secure-app-env -n 101-06-s-secrets -- printenv | grep DB_PASSWORD
----

*Expected output:* `DB_PASSWORD=SuperSecret123`

. Confirm the deployment YAML does not contain the plaintext (only a secretRef):

[source,sh]
----
oc get deploy secure-app-env -n 101-06-s-secrets -o yaml | grep -n 'SuperSecret'
----

*Expected:* No match—the value is not in the deployment spec. Credential is loaded from the Secret at runtime.

=== Use case 4: Deployment mounting Secret as file
Create a second deployment that mounts the Secret as a read-only directory. Each key becomes a file; the app can read the password from the file path. This method allows seamless rotation without restart (see next use case).

*Procedure*

. Create the deployment and add a volume from the Secret, mounted at `/opt/creds`:

[source,sh]
----
oc create deployment secure-app-file -n 101-06-s-secrets --image=registry.access.redhat.com/ubi9/ubi -- sleep infinity
oc set volume deployment/secure-app-file -n 101-06-s-secrets --add --name=creds --type=secret --secret-name=db-credentials --mount-path=/opt/creds --read-only
----

. Wait for the pod and list the mounted files (one per Secret key):

[source,sh]
----
oc wait --for=condition=Available deployment/secure-app-file -n 101-06-s-secrets --timeout=90s
oc exec deploy/secure-app-file -n 101-06-s-secrets -- ls /opt/creds
----

*Expected:* A file named `DB_PASSWORD` (the key name from the Secret).

. Read the file content (same value as in the Secret):

[source,sh]
----
oc exec deploy/secure-app-file -n 101-06-s-secrets -- cat /opt/creds/DB_PASSWORD
----

*Expected output:* `SuperSecret123`

NOTE: File mounts are read-only by default. Applications that support reading config from files can pick up rotated values without a pod restart when you update the Secret.

=== Use case 5: Rotate secret — file updates in place, env needs restart
Update the Secret with a new password. The pod that mounts the Secret as a file will see the new value on the next read; the pod that uses the Secret only as env will keep the old value until it is restarted.

*Procedure*

. Overwrite the Secret with a new value (using dry-run and apply to replace):

[source,sh]
----
oc create secret generic db-credentials -n 101-06-s-secrets --from-literal=DB_PASSWORD=NewValue456 -o yaml --dry-run=client | oc apply -f - -n 101-06-s-secrets
----

. Check the file-mounted pod: it should already show the new value (no restart):

[source,sh]
----
oc exec deploy/secure-app-file -n 101-06-s-secrets -- cat /opt/creds/DB_PASSWORD
----

*Expected output:* `NewValue456`. The mounted file is updated by Kubernetes when the Secret changes.

. Restart the env-based deployment so it picks up the new value:

[source,sh]
----
oc rollout restart deployment/secure-app-env -n 101-06-s-secrets
oc rollout status deployment/secure-app-env -n 101-06-s-secrets --timeout=90s
oc exec deploy/secure-app-env -n 101-06-s-secrets -- printenv | grep DB_PASSWORD
----

*Expected output:* `DB_PASSWORD=NewValue456`. Only after the restart does the env-based pod see the rotated secret.

IMPORTANT: For high-value credentials that you rotate frequently, prefer mounting Secrets as files so updates take effect without restarting pods. Document rotation steps and use RBAC so only authorized identities can update the Secret.

=== Use case 6: Cleanup
*Procedure*

. Delete the project:

[source,sh]
----
oc delete project 101-06-s-secrets --wait=false
----

== What Would You Do?

You moved a hardcoded password into a Secret, used it as env var and as a file mount, and saw that rotation propagates to file mounts immediately but requires a restart for env vars. In your own environment, consider:

* How would you enforce "no secrets in Git" (e.g., pre-commit hooks, gitleaks, or pipeline checks)?
* Would you use an external secret store (e.g., Vault, cloud KMS) and sync into Kubernetes Secrets, or rely on RBAC and etcd encryption-at-rest?
* How would you schedule rotation for high-value secrets and ensure the env-based workloads are restarted or use file mounts?

== Solutions / Controls

* Kubernetes Secrets abstraction
* Etcd encryption-at-rest
* External KMS integration
* RBAC limiting secret get/list
* RHACS anomaly & secret mount policies

== Summary

You deployed an app with a hardcoded password and saw it in the manifest, then removed it and stored the credential in a Kubernetes Secret. You used the Secret as an environment variable (no plaintext in the deployment) and as a mounted file, and rotated the Secret to see that the file-mounted app picked up the new value immediately while the env-based app needed a restart. Secrets plus RBAC reduce exposure and support rotation; prefer file mounts for credentials you rotate often, and never commit real secrets to Git.

== Summary Table
[cols="1,2,2",options="header"]
|===
|Method | Pros | Cons
|Hardcoded Env | Fast demo | Insecure, unrotatable
|Secret as Env Var | Simple | Restart on rotation
|Secret as File | Seamless rotation | Slightly more app logic
|External KMS | Stronger key custody | Extra setup
|===

== FAQs
Are Secrets encrypted by default?:: Base64 only—enable etcd encryption.
Env var or file better?:: File for rotation agility; env for simplicity.
Commit example secrets?:: Use placeholders only.
Do Secrets stop exfiltration?:: Reduce accidental exposure; still need RBAC & network controls.

== Closing Story
Treat secrets like house keys: stored & rotated intentionally, never glued to the door.

== Next Step Ideas

* Periodic rotation pipeline
* External KMS provider integration
* Repo scanning (gitleaks, truffleHog)