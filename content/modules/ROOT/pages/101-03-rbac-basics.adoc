= Lab: Who Really Has Access? (Default RBAC in Action)
:labid: LAB-101-03
:cis-summary: "Limit powerful role use; rely on built-in view/edit/admin tiers instead of broad superuser access."
:mitre-summary: "Prevents unnecessary privilege escalation by using built-in least-privilege roles instead of broad cluster-admin grants."
:audit-evidence: "'oc auth can-i' shows view read-only, edit mutates without RBAC changes, admin adds RoleBinding and secret management."
:cis-mitre-codes: '{"cisMapping":{"primary":["5.1.1"],"supporting":["5.1.2","5.1.5","5.1.8"]},"mitre":{"techniques":["T1078","T1098"],"tactics":["TA0001","TA0003","TA0004"],"mitigations":["M1026","M1012","M1018"]}}'
:toc:
:sectnums:
:icons: font

== Skill
Learn about OpenShift's built-in roles (view, edit, admin) and how they provide graduated levels of access without needing custom roles. You'll practically test what each role allows (from read-only access to full namespace control), understand how to safely escalate permissions step-by-step, and validate access using impersonation—no real user accounts or custom roles required.

== Objective

* Use ONLY default ClusterRoles: view, edit, admin (plus a peek at basic-user & cluster-admin context)
* Observe permission differences (read vs mutate vs manage RBAC)
* Use impersonation (`--as`) to test quickly—no custom identities or new Roles
* See how default roles map to least privilege patterns
* Avoid the “just bind cluster-admin” anti-pattern

== Why it Matters
Imagine an office where every visitor is handed the master key “to avoid delays.” Things go fine—until something disappears or a server closet is “accidentally reorganized.” Most security incidents in access control aren’t brilliant attacks; they’re ordinary over-permission. The default OpenShift roles exist so you do NOT have to invent one-off policies for common personas—and so you avoid reflexively binding cluster-admin.

Using built-in roles: (1) speeds onboarding (“Give them view only”), (2) clarifies escalation paths (progress view → edit → admin), and (3) reduces audit friction (“We rely on documented platform defaults, not bespoke YAML sprawl”). Guardrails work best when widely understood; this lab makes the built-in role intent obvious.

== What it Solves
Teams often jump straight to cluster-admin or craft ad hoc Roles because they aren’t sure what the defaults already deliver. That leads to:

* Wide blast radius (cluster-admin “temporarily” bound forever)
* Hard-to-review custom Role YAML duplicates (inconsistent patterns)
* CI/CD identities holding more verbs than needed (mutation + RBAC management)
* Confusion over “Why can’t view see secret data?” or “Why can edit not alter RoleBindings?”

Built-in roles encode sane boundaries:

* view: Read most namespaced objects (NOT secret contents, NOT RBAC objects) → safe for dashboards & troubleshooting.
* edit: All typical app mutation (deployments, configmaps, services) but still cannot change RBAC → prevents silent privilege extension.
* admin: Full namespace stewardship including Role/RoleBinding management (but not cluster-scoped ownership) → local ‘tenant admin’.
* basic-user: Lets a user get info about themselves and basic project discovery.
* cluster-admin (reference only): Superuser; bypasses almost all policy—should remain a rare operational break-glass identity.

By adopting existing defaults, you eliminate redundant YAML, ease training, and reduce accidental overreach.

== Understanding the Attack Surface
[cols="1,2,2",options="header"]
|===
|Vector | Over-Permission Risk | Example Outcome
|Human User | Namespace deletion, secret exposure | Accidental wipe of workloads
|Service Account | Silent privilege creep | Backdoor pod / lateral move
|CI/CD Identity | Supply chain tampering | Deploys unsigned image
|RoleBinding Sprawl | Hidden stale grants | Former contractor retains edit
|cluster-admin Overuse | Full cluster blast radius | Global outage from one command
|===

== How to Secure (Lifecycle View)

* Build: CI service accounts: just what’s needed to apply manifests (often edit) — never admin.
* Registry: Quay robot accounts limited to push OR pull (not both) to prevent repurposing.
* Deploy: Prefer binding built-in ClusterRoles (view/edit/admin) at namespace scope rather than authoring custom Roles prematurely.
* Runtime: Monitor audit logs or RHACS for privilege jumps (view → admin unexpectedly) and new RoleBindings.
* Governance: Periodically export bindings; compare against team roster. Remove drift quickly.

== Concepts: Built-in Roles and Impersonation

OpenShift ships with *ClusterRoles* such as `view`, `edit`, and `admin` that you bind at namespace scope with a *RoleBinding*. That gives a user or group a well-defined set of permissions in that namespace only. You don't need to create custom Roles for common personas—the platform already encodes least-privilege tiers: view (read most things, no secret data, no RBAC), edit (mutate workloads but not RBAC), admin (full namespace control including RoleBindings and secrets). To test permissions without creating real users, you use *impersonation*: `oc auth can-i <verb> <resource> --as=dev-user` (or `--as=system:serviceaccount:ns:name` for a service account). Impersonation lets you verify exactly what each role allows before rolling it out to your team.

== How to Try It

You will create a sandbox project, bind the built-in roles `view`, `edit`, and `admin` one at a time to a fictitious user `dev-user`, and use `oc auth can-i --as=dev-user` to observe what each role permits. Then you'll confirm that a new ServiceAccount has no permissions until explicitly bound. All steps use only default ClusterRoles and impersonation—no custom Roles or real identities required.

=== Use case 1: Create sandbox project
Create a dedicated namespace so your role-binding experiments don't affect other workloads.

*Procedure*

. Create the project:

[source,sh]
----
oc new-project 101-03-r-rbac
----

NOTE: The project name is arbitrary; use any namespace name that fits your lab conventions.

=== Use case 2: Bind view and verify read-only scope
Bind the `view` ClusterRole to the user `dev-user` in the sandbox namespace. View allows reading and listing most namespaced resources but not secret contents, not RBAC objects, and no create/update/delete. This is the right role for dashboards and read-only troubleshooting.

*Procedure*

. Create a RoleBinding that grants the `view` ClusterRole to `dev-user` in the current namespace:

[source,sh]
----
oc create rolebinding dev-view --clusterrole=view --user=dev-user -n 101-03-r-rbac
----

. Check that `dev-user` can get pods (read):

[source,sh]
----
oc auth can-i get pods --as=dev-user -n 101-03-r-rbac
----

*Expected output:* `yes`

. Check that `dev-user` cannot create a deployment (no write):

[source,sh]
----
oc auth can-i create deployment --as=dev-user -n 101-03-r-rbac
----

*Expected output:* `no`

. Check that `dev-user` cannot read secret data (view deliberately excludes secret contents):

[source,sh]
----
oc auth can-i get secret/mysecret --as=dev-user -n 101-03-r-rbac
----

*Expected output:* `no` (or the command may error if the secret doesn't exist—the important point is that view does not grant secret read).

TIP: Use `oc auth can-i --list --as=dev-user -n 101-03-r-rbac` to see a matrix of allowed verbs and resources for that identity in the namespace.

=== Use case 3: Escalate to edit and verify mutation without RBAC
Remove the view binding and bind `edit` instead. Edit allows typical application mutations (deployments, services, configmaps, etc.) but still does *not* allow creating or changing RoleBindings or Roles. That prevents a compromised or careless identity from granting itself or others more power.

*Procedure*

. Remove the view binding and create an edit binding:

[source,sh]
----
oc delete rolebinding dev-view -n 101-03-r-rbac
oc create rolebinding dev-edit --clusterrole=edit --user=dev-user -n 101-03-r-rbac
----

. Confirm `dev-user` can create deployments:

[source,sh]
----
oc auth can-i create deployment --as=dev-user -n 101-03-r-rbac
----

*Expected output:* `yes`

. Confirm `dev-user` still cannot create a RoleBinding (no RBAC changes):

[source,sh]
----
oc auth can-i create rolebinding --as=dev-user -n 101-03-r-rbac
----

*Expected output:* `no`

IMPORTANT: The separation between "can change workloads" and "cannot change RBAC" is intentional. Edit is safe for developers and CI/CD that need to deploy and update apps but should not be able to escalate their own permissions.

=== Use case 4: Escalate to admin and verify full namespace control
Replace the edit binding with `admin`. Admin grants full namespace stewardship: create/update/delete workloads, manage secrets, and create or modify RoleBindings and Roles within the namespace. It does *not* grant cluster-scoped privileges (e.g., creating namespaces or cluster-wide resources).

*Procedure*

. Remove the edit binding and create an admin binding:

[source,sh]
----
oc delete rolebinding dev-edit -n 101-03-r-rbac
oc create rolebinding dev-admin --clusterrole=admin --user=dev-user -n 101-03-r-rbac
----

. Confirm `dev-user` can now create a RoleBinding:

[source,sh]
----
oc auth can-i create rolebinding --as=dev-user -n 101-03-r-rbac
----

*Expected output:* `yes`

. Confirm `dev-user` can delete secrets (full namespace control):

[source,sh]
----
oc auth can-i delete secret --as=dev-user -n 101-03-r-rbac
----

*Expected output:* `yes`

=== Use case 5: Workload check under edit or admin
With `dev-user` still bound as admin (or you can re-bind edit and compare), create a deployment and then list it as `dev-user` to confirm the identity can see and interact with workloads in the namespace.

*Procedure*

. Create a simple deployment in the sandbox namespace:

[source,sh]
----
oc create deployment sample --image=registry.access.redhat.com/ubi9/ubi -- sleep infinity -n 101-03-r-rbac
----

. List deployments as `dev-user` (works with either edit or admin):

[source,sh]
----
oc get deploy -n 101-03-r-rbac --as=dev-user
----

*Sample output*

[source,text]
----
NAME     READY   UP-TO-DATE   AVAILABLE   AGE
sample   1/1     1            1           30s
----

NOTE: With edit or admin, the user can create, update, and delete such workloads. With view only, the user could list and get but not modify.

=== Use case 6: ServiceAccount conservative default
A newly created ServiceAccount has *no* RoleBindings by default. So it cannot list, create, or delete resources until you explicitly bind a role to it. This demonstrates that OpenShift does not grant service accounts any default permissions—you must opt in.

*Procedure*

. Create a ServiceAccount in the sandbox namespace:

[source,sh]
----
oc create sa app-sa -n 101-03-r-rbac
----

. Check whether that ServiceAccount can list secrets (it should be denied):

[source,sh]
----
oc auth can-i list secrets --as=system:serviceaccount:101-03-r-rbac:app-sa -n 101-03-r-rbac
----

*Expected output:* `no`

. Optionally bind a role to the ServiceAccount and re-run the same check to see it change to `yes`:

[source,sh]
----
oc create rolebinding app-sa-view --clusterrole=view --serviceaccount=101-03-r-rbac:app-sa -n 101-03-r-rbac
oc auth can-i list pods --as=system:serviceaccount:101-03-r-rbac:app-sa -n 101-03-r-rbac
----

TIP: For CI/CD or in-cluster apps, bind the minimum role needed (often `edit` for deploy pipelines, never `cluster-admin` unless break-glass). Document each binding and review periodically.

=== Use case 7: Cleanup
Remove the project and all resources. Use `--wait=false` to return immediately while the namespace terminates in the background.

*Procedure*

. Delete the project:

[source,sh]
----
oc delete project 101-03-r-rbac --wait=false
----

. Optionally wait for the namespace to be gone:

[source,sh]
----
oc get namespace 101-03-r-rbac
# Repeat until "NotFound"
----

== What Would You Do?

You tested view, edit, and admin with a single impersonated user and saw that a new ServiceAccount starts with no permissions. In your own environment, consider:

* How would you map your teams (e.g., developers, SRE, auditors) to view vs edit vs admin in each namespace?
* Would you use a GitOps repo to store RoleBindings so every change is reviewed and auditable?
* How would you detect unexpected privilege changes—for example, a service account suddenly bound to admin—using RHACS or OpenShift audit logs?

== Solutions / Controls
[cols="1,2,2",options="header"]
|===
|Control | Purpose | Analogy
|Built-in view/edit/admin | Standardized least privilege tiers | Pre-printed ID badge levels
|RoleBinding per namespace | Limits scope & improves audit clarity | Key to a single floor
|Avoid cluster-admin bindings | Shrinks blast radius | Master key in vault, not on lanyard
|RHACS & Audit Logs | Detect unexpected verb usage | Security cameras + access logs
|GitOps-managed RBAC | Versioned, reviewable changes | Change tickets for keys
|Periodic Binding Review | Remove stale access | Quarterly key audit
|===

== Summary Table
[cols="1,2,2,2,2",options="header"]
|===
|Built-in Role | Grants | Excludes | Primary Use | Risk If Overused
|view | Read/list most objects | Mutations, RBAC mgmt, secret data | Observability / dashboards | False sense secrets are readable
|edit | Create/update/delete app resources | RBAC changes, some cluster ops | Dev & CI workload changes | Accidental destructive edits
|admin | All namespace + RBAC mgmt | Cluster-wide operations | Namespace owner / team lead | Local “root” misuse
|basic-user | Self & project discovery | Workload mutation | User info queries | Minimal risk
|cluster-admin (avoid) | Everything | — | Break-glass ops only | Total cluster compromise
|===

== Summary

You used impersonation to test the built-in roles view, edit, and admin in a sandbox namespace: view allowed read-only access, edit allowed workload mutation but not RBAC changes, and admin allowed full namespace control including RoleBindings and secrets. You also confirmed that a new ServiceAccount has no permissions until you bind a role to it. Relying on these defaults reduces custom YAML, clarifies escalation paths, and avoids the "just bind cluster-admin" anti-pattern.

== FAQs
How do I quickly test a permission?:: `oc auth can-i <verb> <resource> --as=<user>` (add `-n <ns>` if needed).
Why use ClusterRole (view/edit/admin) instead of writing a Role?:: They are predefined, maintained by the platform, and widely recognized—fewer bespoke policies to audit.
Why can’t view read secret contents?:: Protects sensitive configuration; grant only when necessary.
Why can edit not change RBAC?:: Prevents silent privilege elevation by identities that can already mutate apps.
When is admin appropriate?:: When a team needs full stewardship of its namespace including RoleBindings—but still not cluster-wide control.
Should I ever bind cluster-admin to a user?:: Avoid; reserve for break-glass operations with logging and time-bound justification.
Does RBAC replace vulnerability management?:: No; it limits blast radius after compromise.

== Closing Story
Default RBAC roles are the building’s standard badge templates. Consistency shrinks review effort, prevents “temporary” superuser drift, and turns access audits from archaeology into a glance.

== Next Step Ideas

* Script a periodic “can-i” matrix for critical identities
* Enforce a rule: no direct ClusterRoleBinding unless justified in Git
* Add RHACS policy: alert when service account gains admin-level verbs